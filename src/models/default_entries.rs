use chrono::{DateTime, Datelike, Duration, FixedOffset, Utc, Weekday};
use tracing::debug;

use crate::entities::mrbs_entry::{self, Entity as Mrbs_entry};
use crate::entities::mrbs_participants::{self, Entity as Mrbs_Participants};
use crate::entities::mrbs_repeat::{self, Column, Entity as Mrbs_repeat};

use sea_orm::{
    ActiveModelTrait, ColumnTrait, Condition, DatabaseConnection, EntityTrait, QueryFilter,
    QueryOrder, QuerySelect, Set,
};
use share_types_booking::planner_types::{EntryRelatedData, ErrorType, ResponseType};

use super::help_fn::TimeFunctions;
use super::read::collect_area_rooms;

pub trait EntryOperation {
    async fn apply(
        &self,
        db: &DatabaseConnection,
        current: DateTime<FixedOffset>,
        room_id: i32,
        room_name: &str,
        room_capacity: i32,
    ) -> Result<(), ErrorType>;
}

pub struct CreateOperation;
impl EntryOperation for CreateOperation {
    async fn apply(
        &self,
        db: &DatabaseConnection,
        current: DateTime<FixedOffset>,
        room_id: i32,
        room_name: &str,
        room_capacity: i32,
    ) -> Result<(), ErrorType> {
        if check_entry_roomid(db, room_id, &current.to_rfc3339())
            .await?
            .is_none()
        {
            set_entry_default(db, current, room_id, room_name, room_capacity).await?;
        }
        Ok(())
    }
}

pub struct DeleteOperation;

impl EntryOperation for DeleteOperation {
    async fn apply(
        &self,
        db: &DatabaseConnection,
        current: DateTime<FixedOffset>,
        room_id: i32,
        _room_name: &str,
        _room_capacity: i32,
    ) -> Result<(), ErrorType> {
        match check_entry_roomid(db, room_id, &current.to_rfc3339()).await? {
            Some(entry_id) => delete_entry(db, current, entry_id).await,
            None => Ok(()),
        }
    }
}

pub async fn operate_entry<T: EntryOperation>(
    db: &DatabaseConnection,
    param: Option<Vec<String>>,
    operation: &T,
) -> Result<ResponseType, ErrorType> {
    let start: DateTime<FixedOffset>;
    let end: DateTime<FixedOffset>;
    match param {
        Some(res) => {
            start = DateTime::parse_from_rfc3339(&res[0])
                .map_err(|_e| ErrorType::GivenTimeIsNotRCF3339)?;
            end = DateTime::parse_from_rfc3339(&res[1])
                .map_err(|_e| ErrorType::GivenTimeIsNotRCF3339)?;
        }
        None => return Err(ErrorType::NoDateFound)?,
    };
    let area_data: Vec<EntryRelatedData> = collect_area_rooms(db).await?;
    let mut current = start;
    while current <= end {
        // No Weekend check
        if current.weekday() != Weekday::Sat && current.weekday() != Weekday::Sun {
            for a in &area_data {
                for room in &a.rooms {
                    operation
                        .apply(db, current, room.id, &room.room_name, room.capacity)
                        .await?;
                }
            }
        }
        current = current + Duration::days(1);
    }
    Ok(ResponseType::SuccessfulJoined)
}

pub async fn set_entry_default(
    db: &DatabaseConnection,
    current: DateTime<FixedOffset>,
    room_id: i32,
    room_name: &str,
    room_capacity: i32,
) -> Result<i32, ErrorType> {
    let default_start: u32 = 7;
    let default_end: u32 = 17;
    let allow_registration: i8 = 1; //default
    let entry_type: i32 = 1; // default
    let repeat_id = check_repeat_room(db, room_id, current).await?;

    let new_entry = mrbs_entry::ActiveModel {
        room_id: Set(room_id),
        entry_type: Set(entry_type),
        start_time: Set(TimeFunctions::get_timestamp_hour(current, default_start)),
        end_time: Set(TimeFunctions::get_timestamp_hour(current, default_end)),
        create_by: Set("autogenerated".to_owned()),
        timestamp: Set(Utc::now()),
        registrant_limit: Set(room_capacity),
        allow_registration: Set(allow_registration),
        registrant_limit_enabled: Set(allow_registration),
        name: Set(room_name.to_owned()),
        repeat_id: Set(Some(repeat_id)),
        ..Default::default()
    };
    let res_id = mrbs_entry::Entity::insert(new_entry)
        .exec(db)
        .await
        .map_err(|_| ErrorType::DBError)?;
    Ok(res_id.last_insert_id)
}

pub async fn delete_entry(
    db: &DatabaseConnection,
    current: DateTime<FixedOffset>,
    entry_id: i32,
) -> Result<(), ErrorType> {
    Mrbs_entry::delete_by_id(entry_id)
        .exec(db)
        .await
        .map_err(|_error| ErrorType::FailedDelete)?;
    debug!("Entry ID :{:?} is deleted on date {:?}", entry_id, current);
    Mrbs_Participants::delete_many()
        .filter(mrbs_participants::Column::EntryId.eq(entry_id))
        .exec(db)
        .await
        .map_err(|_error| ErrorType::FailedDelete)?;
    Ok(())
}

async fn check_entry_roomid(
    db: &DatabaseConnection,
    id: i32,
    timegiven: &str,
) -> Result<Option<i32>, ErrorType> {
    match TimeFunctions::rfc3339_to_unixtimestamp(timegiven) {
        Ok(res) => {
            let condition_day = Condition::all()
                .add(mrbs_entry::Column::RoomId.eq(id))
                .add(mrbs_entry::Column::StartTime.gte(res.0))
                .add(mrbs_entry::Column::EndTime.lte(res.1));
            Ok(Mrbs_entry::find()
                .filter(condition_day)
                .select_only()
                .column(mrbs_entry::Column::Id)
                .into_tuple()
                .one(db)
                .await
                .map_err(|_error| ErrorType::DBError)?)
        }
        Err(_) => Err(ErrorType::GivenTimeIsNotRCF3339)?,
    }
}

pub async fn check_repeat_room(
    db: &DatabaseConnection,
    room_id: i32,
    timegiven: DateTime<FixedOffset>,
) -> Result<i32, ErrorType> {
    let last_repeat: Option<(i32, i32)> = Mrbs_repeat::find()
        .filter(mrbs_repeat::Column::RoomId.eq(room_id))
        .select_only()
        .columns([mrbs_repeat::Column::Id, mrbs_repeat::Column::EndDate])
        .order_by_desc(Column::EndDate)
        .limit(1)
        .into_tuple()
        .one(db)
        .await
        .map_err(|_error| ErrorType::DBError)?;
    debug!("repeat id: {:?}", last_repeat);
    match last_repeat {
        Some(repeat_entry) => {
            if timegiven
                > DateTime::from_timestamp(repeat_entry.1.into(), 0)
                    .ok_or(ErrorType::GivenTimeIsNotRCF3339)?
            {
                set_repeat_enddate(db, repeat_entry.0, timegiven).await?;
                Ok(repeat_entry.0)
            } else {
                Ok(repeat_entry.0)
            }
        }
        None => todo!(),
    }
}

async fn set_repeat_enddate(
    db: &DatabaseConnection,
    repeat_id: i32,
    old_date: DateTime<FixedOffset>,
) -> Result<(), ErrorType> {
    let mut change_repeat: mrbs_repeat::ActiveModel = Mrbs_repeat::find_by_id(repeat_id)
        .one(db)
        .await
        .map_err(|_e| ErrorType::NoDateFound)?
        .ok_or(ErrorType::NoDateFound)?
        .into();
    change_repeat.end_date =
        Set(TimeFunctions::end_of_year(old_date).ok_or(ErrorType::NoDateFound)?);
    change_repeat
        .update(db)
        .await
        .map_err(|_e| ErrorType::DBError)?;
    Ok(())
}
