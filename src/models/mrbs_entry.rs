use chrono::{FixedOffset, Utc};
use loco_rs::prelude::*;
use sea_orm::{Condition, QuerySelect};
use sea_orm::entity::prelude::*;
use tracing::info;
use crate::models::_entities::mrbs_entry;
use crate::models::help_fn::TimeFunctions;
use crate::models::mrbs_participants::MrbsParticipants;
use crate::models::mrbs_repeat::MrbsRepeat;
use crate::models::mrbs_room::RoomsRelatedData;
use crate::response_type::error::ErrorType;
use crate::response_type::success::ResponseType;
pub use super::_entities::mrbs_entry::{ActiveModel, Model, Entity};
pub type MrbsEntry = Entity;
pub type MrbsEntryActiveModel = ActiveModel;
#[async_trait::async_trait]
impl ActiveModelBehavior for ActiveModel {}
// implement your read-oriented logic here
impl Model {}

// implement your write-oriented logic here
impl ActiveModel {
    pub async fn set_entry_default(
        db: &DatabaseConnection,
        current: Option<chrono::DateTime<FixedOffset>>,
        room_id: i32,
        room_name: &str,
        room_capacity: i32,
    ) -> Result<i32, Response> {
        let default_start: u32 = 7;
        let default_end: u32 = 17;
        let allow_registration: i8 = 1; //default
        let entry_type: i32 = 1; // default
        let entry_date = match current { 
            Some(current) => {current},
            None => Utc::now().with_timezone(&FixedOffset::east_opt(2 * 3600).unwrap()),
        };
        let repeat_id = MrbsRepeat::check_repeat_room(db, room_id, entry_date).await.ok();

        let new_entry = mrbs_entry::ActiveModel {
            room_id: Set(room_id),
            entry_type: Set(entry_type),
            start_time: Set(TimeFunctions::get_timestamp_hour(entry_date, default_start)),
            end_time: Set(TimeFunctions::get_timestamp_hour(entry_date, default_end)),
            create_by: Set("autogenerated".to_owned()),
            timestamp: Set(Some(Utc::now())),
            registrant_limit: Set(room_capacity),
            allow_registration: Set(allow_registration),
            registrant_limit_enabled: Set(allow_registration),
            name: Set(room_name.to_owned()),
            repeat_id: Set(repeat_id),
            ..Default::default()
        };
        let res_id = mrbs_entry::Entity::insert(new_entry)
            .exec(db)
            .await
            .map_err(|_| ErrorType::DBError.into_response())?;
        Ok(res_id.last_insert_id)
    }
    
    pub async fn delete_entry_by_id(
        db: &DatabaseConnection,
        entry_id: i32,
    ) -> Result<Response, Response> {
        info!("id: {:?}", entry_id);
        let res = MrbsEntry::delete_by_id(entry_id)
            .exec(db)
            .await
            .map_err(|_error| ErrorType::FailedDelete.into_response())?;
        info!("Delete entry by id: {:?}", res);
        Ok(ResponseType::SuccessfulDelete.into_response())
    }
}

// implement your custom finders, selectors oriented logic here
impl Entity {
    pub async fn find_by_day_range(
        db: &DatabaseConnection,
        rooms: &mut RoomsRelatedData,
        day_range: (i32, i32)
    ) -> Result<(), Response> {
        let condition_day = Condition::all()
            .add(mrbs_entry::Column::RoomId.eq(rooms.id))
            .add(mrbs_entry::Column::StartTime.gte(day_range.0))
            .add(mrbs_entry::Column::EndTime.lte(day_range.1));
        let entryid_limit: Option<(i32, i32)> = MrbsEntry::find()
            .filter(condition_day)
            .select_only()
            .columns(
                [mrbs_entry::Column::Id, mrbs_entry::Column::RegistrantLimit]
            )
            .into_tuple()
            .one(db)
            .await
            .map_err(|_error| ErrorType::DBError.into_response())?;
        // all participants for all rooms and there paricipants_id default 0
        match entryid_limit {
            Some(e) => {
                let participants_collection = MrbsParticipants::find_by_entry_id(  db, e.0).await?;
                rooms.participants = participants_collection;
                rooms.entry_id = Some(e.0);
                rooms.registration_limit = e.1;
            }
            None => {
                rooms.entry_id = None;
                rooms.registration_limit = rooms.capacity;
            }
        }
        Ok(())
    }
    
    pub async fn get_limit_by_entry_id(db: &DatabaseConnection, entry_id: i32) -> Result<Option<i32>, Response>{
        Ok(MrbsEntry::find()
            .filter(mrbs_entry::Column::Id.eq(entry_id))
            .select_only()
            .column(mrbs_entry::Column::RegistrantLimit)
            .into_tuple()
            .one(db)
            .await
            .map_err(|_error| ErrorType::NoEntry {
                message: _error.to_string() + "limit",
            }.into_response())?)
    }
    
    pub async fn get_entry_id_by_day_range(db: &DatabaseConnection, room_id: i32, date: (i32, i32)) -> Result<Option<i32>, Response> {
        let condition_day = Condition::all()
            .add(mrbs_entry::Column::RoomId.eq(room_id))
            .add(mrbs_entry::Column::StartTime.gte(date.0))
            .add(mrbs_entry::Column::EndTime.lte(date.1));

        Ok(MrbsEntry::find()
            .filter(condition_day)
            .select_only()
            .columns([mrbs_entry::Column::Id])
            .into_tuple()
            .one(db)
            .await
            .map_err(|_error| ErrorType::DBError.into_response())?)
    }

    

    pub async fn check_entry_roomid(
        db: &DatabaseConnection,
        id: i32,
        timegiven: &str,
    ) -> Result<Option<i32>, Response> {
        match TimeFunctions::rfc3339_to_unixtimestamp(timegiven) {
            Ok(date) => {
                let condition_day = Condition::all()
                    .add(mrbs_entry::Column::RoomId.eq(id))
                    .add(mrbs_entry::Column::StartTime.gte(date.0))
                    .add(mrbs_entry::Column::EndTime.lte(date.1));
                Ok(MrbsEntry::find()
                    .filter(condition_day)
                    .select_only()
                    .column(mrbs_entry::Column::Id)
                    .into_tuple()
                    .one(db)
                    .await
                    .map_err(|_error| ErrorType::DBError.into_response())?)
            }
            Err(_) => Err(ErrorType::GivenTimeIsNotRCF3339.into_response())?,
        }
    }

}
